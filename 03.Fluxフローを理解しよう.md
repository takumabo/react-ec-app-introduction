ここではFluxフローについて理解しましょう。

そもそもなんんでreduxを使う必要があるんでしょうか？
その理由は主に３つあります。
```
1.stateの見通しをよくするため
2.どこからでもstateの参照と変更を可能にするため
3.モジュールを疎結合するため =　機能Aと機能Bが互いに影響し合わない
```
これが理由になります。

1.stateの見通しをよくするため
reduxを使わない場合はreactのコンポーネントの中身だけでstateを管理するけどreduxのstoreを使うことでそれを１つに管理することができる。

2.どこからでもstateの参照と変更を可能にするため
前述したstoreはある作法にのっとればどこからでもstateを参照したり変更することができる。
どのコンポーネントからでもそれを参照 / 変更できるのでマジめっちゃ優れもの。

3.モジュールを疎結合するため =　機能Aと機能Bが互いに影響し合わない
モジュールとはなんかの機能を持った塊で、ロボットで言う部品のような役割です。例えば片方のモジュールに変更を加えた時に別のモジュールが影響しちゃうとかなり保守しづらいですよね。
そうならないためにreduxを使ってモジュールを疎結合させる必要があります。ちなみに逆の言葉を密結合です。

reactだけでstateを管理するとpropsのバケツリレーが発生します。
これだとそれぞれのコンポーネントでstateの管理をしないといけないのでかなり危険です。この状態はかなり密結合です。
それを回避するためにreduxのstoreを使うことで、
stateの変更依頼をstoreに伝達し、関連する別コンポーネントに直接storeから変更させることができます。これで疎結合になります。便利ですね。


では本題に戻って、Fluxフローとはなんぞやと言う話ですが、
それは
1.データフロー設計の１つ
2.データが常に１方向に流れる
3.イベントによってデータが変化(イベントが発生した時のみの駆動)

で、このFlux思想をReactの状態管理に適用したライブラリ=Reduxなんですね。

では実際にreduxで扱う登場人物をここで抑えましょう。()は例

conponent：実際にユーザーが扱うところ(商品)
container：Storeと接続されたコンポーネント(お店自体)
Action：要求を受けて変更を依頼(お店の店員さんでユーザーの購入を受けてバックにいる人に伝える役割)　変更を依頼すること自体を「dispatch」と言います。
reducer；変更の管理をする(在庫管理をする人。)Actionであった要求に対して何をすべきかと言う変更を管理するところ
Store：状態を保存する場所(倉庫な役割)
map：mapStateToPropsとmapDispatchToPropsを実行する=Storeで状態が変更された時にその変更をcontainerに渡してユーザーが見えているところに反映してあげるためのもの(containerを通してユーザーに渡す作業。)


こんな感じです。
次回から実際にActionを作成して流れを掴んでいきましょう。



